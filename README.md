קודם כל אסביר על מימוש הפונקציות השונות במטלה:

**הפונקציות ב- Graph.cpp:** 

**הראשונה: loadGraph** מקבלת מטריצה וטוענת אותה לתוך הגרף.

בודקת אם הגרף מכוון, אם יש צלעות שליליות, משקל וכו׳ ונותנת ערכים לשדות המתאימים בהתאם לזה.

**הפונקציה הבאה printGraph** - אם הגרף לא מכוון נספור כל שתי צלעות כאחת, כי אין כיוונים לכן הצלע מקודקוד 0 ל-1

ומקודקוד 1 ל-0 זה אותה צלע. לכן נדפיס את סה״כ הצלעות שספרנו ונחלק ב-2
.
אם הגרף מכוון נדפיס פשוט את סה״כ הצלעות שספרנו.

**הפונקציות ב- Algorithms.cpp:** 

**הראשונה isConnected(g)** - מקבלת גרף ובודקת האם הוא קשיר.

נעשה זאת ע״י DFSAlgo פונקציה שכתבתי במחלקת DFS שעושה DFS מקודקדוד.

אם הגרף לא מכוון נריץ DFS פעם אחת ואם יש קודקוד שלא ביקרנו בו אז הגרף לא קשיר.

אם ביקרנו בכל הקודקודים בגרף הגרף קשיר.

אם הגרף מכוון נריץ DFS מכל קודקוד ונבדוק שביקרנו בכל הקודקודים, כי לצלעות כעת יש כיווו אז יכול להיות

שמקודקוד אחד אפשר להגיע לאחר אך מאחר אי אפשר להגיע אליו. אם יש קודקוד שלא ביקרנו בו אז הגרף לא קשיר.

אם ביקרנו בכל הקודקודים בכל הריצות הגרף קשיר.

**הפונקציה הבאה shortestPath(g,start,end)** - מקבלת גרף קודקוד התחלה וקודקוד סיום.

נממש באופן הבא: 

אם יש רק צלעות ללא משקלים - נריץ BFSAlgo מהמחלקה BFS שכתבתי שעושה BFS ומחשבת מסלול הכי קצר בגרף לא ממשוקל
מקודקוד התחלה לקודקוד סיום.

אם יש רק משקלים חיוביים - נריץ DijkstraAlgo מהמחלקה Dijkstra שכתבתי שעושה דיאקסטרה ומחשבת את המסלול הכי קצר בגרף ממשוקל בעל צלעות חיוביות
מקודקוד התחלה לקודקוד סיום.

אם יש משקלים שליליים - נריץ BellmanFordAlgo מהמחלקה BellmanFord שכתבתי שעושה בלמן פורד ומחשבת את המסלול הכי קצר בגרף בעל משקלים שליליים אך ללא מעגלים שליליים
מקודקוד התחלה לקודקוד סיום, אם נמצא מעגל שלילי היא תחזיר שנמצא מעגל שלילי.

לבסוף נחזיר את המסלול הכי קצר, אם לא נמצא כזה נחזיר -1.

**הפונקציה הבאה isContainsCycle(g)** - מקבלת גרף ובודקת האם הוא מכיל מעגל

אסביר את אופן המימוש:

מריץ את הפונקציה DFSToFindCycle על כל הקודקודים מהמחלקה DFS בה נריץ DFS
ונבדוק אם מצאנו צלע אחורה וחזרנו לקודקוד שכבר ביקרנו בו, מצאנו מעגל.

לאחר מכן נחזיר את המעגל אותו מצאנו, אם לא מצאנו מעגל נחזיר 0.

**הפונקציה הבאה isBipartite(g)** - מקבלת גרף ובודקת אם אפשר לחלק את הגרף לדו צדדי.

נממש ע״י בדיקה האם הגרף 2 צביע, נרוץ על הקודקודים ונחלק אותם ל-2 צבעים על פי הצלעות שיוצאות מהם.

אם לא קיימת צלע בין שני קודקודים בעלי אותו צבע, נחזיר את החלוקה. 
כאשר הקבוצה הראשונה תהיה A והקבוצה השניה תהיה B.

אם לא נצליח לחלק את הקודקודים לשתי צבעים כך שלא יהיה צלע שעוברת בין שני קודקודים בעלי אותו צבע, 
נחזיר 0.

**הפונקציה הבאה negativeCycle(g)** - מקבלת גרף ובודקת האם יש מעגל שלילי במידה וכן, מחזירה אותו.

נממש ע״י בדיקה האם הגרף מכוון, אם כן נשתמש בפונקציה BellmanFordToFindNegativeCycle מהמחלקה BellmanFord.

שמוסיפה קודקוד חיצוני לגרף עם צלעות לכל הקודקודים הקיימים ועושה בלמן פורד ממנו.

ועושה relax n-1 פעמים לכל הצלעות, ובפעם ה-n בודקת האם עדיין ניתן לעשות relax לצלע.

אם כן היא מוסיפה את קודקוד הסיום שלה למעגל ועוברת על המצביעים שלו עד שהיא רואה אותו צלע פעמיים.

לאחר מכן היא מצמצמת את המערך קודקודים בעזרת הפונקציה checkVerTwice למערך מהקודקוד הראשון שראינו פעמיים. 

עד הפעם השניה שראינו אותו, כך אם נכנסה צלע שהיא לא חלק מהמעגל השלילי אנו מורידים אותה. 

במידה ואין מעגל שלילי אנו מחזירים שלא קיים כזה.

בהתאם לפונקציות האלה אותם מימשתי בניתי **20 טסטים במחלקה tests** שעובדים. 

**ובניתי makefile** שבאמצעות הפקודה make runDemo נריץ את ה-demo
ובאמצעות make runTest נריץ את הטסטים.

זהו (:







